<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
  </head>
  <body>
    <canvas id="canvas" height="480" width="640"></canvas>
    <textarea id="program" rows="20" cols="33">
// Polyeder is a list: [faces, vertices]
// faces is a list of f32 Vectors
// vertices is a list of f32 Vectors

const EPS = 1e-3;
const PHI = (1. + sqrt(5.)) / 2.;

fn roll(v, i) {
  if i == 0 {
    return v;
  }
  if i == 1 {
    return Vector(v[1], v[2], v[0]);
  }
  if i == 2 {
    return Vector(v[2], v[0], v[1]);
  }
  throw "invalid roll";
}

// Input is an Array of Vertices.
fn autoface(v) {
  // WARNING: ONLY WORKS IF ALL EDGES HAVE EQUAL LENGTH
  let f = [];
  let edge_length = 1e10;
  for (a, ai) in v {
    for (b, bi) in v {
      if ai == bi {
        continue;
      }
      let l = (a - b).norm();
      if l < edge_length {
        edge_length = l;
      }
    }
  }

  for (a, ai) in v {
    for (b, bi) in v {
      if bi <= ai || (a - b).norm() > (edge_length + global::EPS) {
        continue;
      }
      for (c, ci) in v {
        if ci <= bi || (a - c).norm() > (edge_length + global::EPS) {
          continue;
        }
        let n = (b - a).cross(c - a);
        n /= n.norm();
        let d = n.dot(a);
        if d < 0. {
          n = -n;
          d = -d;
        }
        let flag = true;
        for p in v {
          if n.dot(p) > (d + global::EPS) {
            flag = false;
            break;
          }
        }
        if flag {
          f.push([n, -d]);
        }
      }
    }
  }
  return f;
}

// Input is an Array of Faces.
fn make_obj(faces) {
  let planes = [];
  for f in faces {
    planes.push(Plane(f[0], f[1]));
  }
  return Intersection(planes).smooth_exponential(16.0);
}

fn addpointsevensgn(p) {
  let v = [];
  for m in [Vector( 1.,  1., 1.),
            Vector(-1., -1., 1.),
            Vector(-1.,  1.,-1.),
            Vector( 1., -1.,-1.)] {
    v.push(m * p);
  }
  return v;
}

fn addpointssgn(a, s) {
  let v = [a];
  if s[0] != 0. {
    v += addpointssgn(a * Vector(-1.,1.,1.), s * Vector(0.,1.,1.));
  }
  if s[1] != 0. {
    v += addpointssgn(a * Vector(1.,-1.,1.), s * Vector(0.,0.,1.));
  }
  if s[2] != 0. {
    v.push(a * Vector(1.,1.,-1.));
  }
  return v;
}

fn addevenpermssgn(a, s) {
  let v = [];
  for r in 0..3 {
    v += addpointssgn(roll(a, r), roll(s, r));
  }
  return v;
}

// Platonic Solids

fn tetrahedron() {
  let v = addpointsevensgn(Vector(1., 1., 1.));
  return autoface(v);
}

fn hexahedron() {
  let v = addpointssgn(Vector(1., 1., 1.), Vector(1., 1., 1.));
  return autoface(v);
}

fn octahedron() {
  let v = addevenpermssgn(Vector(1.,0.,0.), Vector(1.,0.,0.));
  return autoface(v);
}

fn dodecahedron() {
  let v = addpointssgn(Vector(1.,1.,1.), Vector(1.,1.,1.));
  v += addevenpermssgn(Vector(0., 1. / global::PHI, global::PHI) , Vector(0.,1.,1.));
  return autoface(v);
}

fn icosahedron() {
  let v = addevenpermssgn(Vector(0., 1., global::PHI) , Vector(0.,1.,1.));
  return autoface(v);
}

// Archimedian Solids


// Platonic Solids
//make_obj(tetrahedron())
//make_obj(hexahedron())
//make_obj(octahedron())
//make_obj(dodecahedron())
make_obj(icosahedron())



    </textarea>
    <button id="run" type="button">Run</button>    
    <textarea id="output" rows="20" cols="33" readonly="true"></textarea>    
  </body>
</html>
